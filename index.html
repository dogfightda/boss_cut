<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>게임 보스 리젠 타이머 Ver1.5</title>
    <!-- Firebase SDK 추가 -->
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-database-compat.js"></script>
    <script>
        // 음성 재생 함수
        let lastTTS = { text: '', time: 0 };
        function speak(text) {
            const now = Date.now();
            if (lastTTS.text === text && now - lastTTS.time < 2000) return; // 2초 이내 중복 방지
            lastTTS = { text, time: now };
            try {
                // 앱(WebView)에서 실행 중이면 네이티브 함수 호출
                if (window.android && typeof window.android.speak === 'function') {
                    // window.android.speak(text); // 네이티브 호출 주석처리
                    return;
                }
                // 일반 브라우저에서는 기존 방식 사용
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = 'ko-KR';
                    utterance.rate = 1.0;
                    utterance.pitch = 1.0;
                    utterance.volume = 1.0;
                    window.speechSynthesis.speak(utterance);
                } else {
                    const audio = new Audio();
                    audio.src = `https://translate.google.com/translate_tts?ie=UTF-8&q=${encodeURIComponent(text)}&tl=ko&client=tw-ob`;
                    audio.play();
                }
            } catch (error) {
                console.error('음성 재생 중 오류 발생:', error);
            }
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 8px;
            color: #333;
            margin: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 10px;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
            padding: 12px;
        }

        .header {
            text-align: center;
            margin-bottom: 12px;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 6px;
            color: white;
            position: relative;
        }

        

        .login-status {
            position: absolute;
            top: 8px;
            right: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
        }

        .login-form {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            margin-bottom: 15px;
            text-align: center;
        }

        .login-form h3 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .login-inputs {
            display: flex;
            gap: 8px;
            justify-content: center;
            align-items: end;
            flex-wrap: wrap;
        }

        .login-inputs input {
            padding: 8px;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            font-size: 0.9rem;
            min-width: 150px;
        }

        .admin-only {
            display: none !important;
        }

        .admin-logged-in .admin-only {
            display: block !important;
        }

        .admin-logged-in .delete-btn {
            display: inline-block !important;
        }

        .delete-btn {
            display: none !important;
        }

        .user-info {
            background: rgba(255, 255, 255, 0.2);
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
        }

        .logout-btn, .login-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: background 0.3s;
        }

        .logout-btn:hover, .login-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .header h1 {
            font-size: 1.6rem;
            margin-bottom: 4px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 0.8rem;
            opacity: 0.9;
            margin: 0;
        }

        .control-panel {
            margin-bottom: 12px;
        }

        .add-boss-form {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }

        .add-boss-form h3 {
            margin-bottom: 8px;
            color: #2c3e50;
            font-size: 1rem;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 180px 1fr;
            gap: 8px;
            margin-bottom: 8px;
        }

        .form-group label {
            display: block;
            margin-bottom: 2px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.8rem;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 6px;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            font-size: 0.85rem;
            transition: border-color 0.3s;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }

        .btn-kill {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 0.75rem;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }

        .stat-card {
            background: linear-gradient(45deg, #2c3e50, #34495e);
            color: white;
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-number {
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 2px;
        }

        .stat-label {
            font-size: 0.7rem;
            opacity: 0.8;
        }

        .boss-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 6px;
            margin-top: 8px;
        }

        .boss-card {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 8px 12px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            min-height: 45px;
        }

        .boss-card.alive {
            border-color: #27ae60;
            background: linear-gradient(135deg, #ffffff 0%, #f8fff8 100%);
        }

        .boss-card.dead {
            border-color: #e74c3c;
            background: linear-gradient(135deg, #ffffff 0%, #fff8f8 100%);
        }

        .boss-card.respawn-soon {
            border-color: #f39c12;
            background: linear-gradient(135deg, #ffffff 0%, #fffbf0 100%);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(243, 156, 18, 0.3); }
            50% { box-shadow: 0 0 0 3px rgba(243, 156, 18, 0); }
        }

        .boss-left {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
            min-width: 0;
        }

        .boss-name {
            font-size: 1rem;
            font-weight: 700;
            color: #2c3e50;
            margin: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 100px;
        }

        .boss-status {
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.6rem;
            font-weight: 600;
            text-transform: uppercase;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .status-alive {
            background: #27ae60;
            color: white;
        }

        .status-dead {
            background: #e74c3c;
            color: white;
        }

        .status-soon {
            background: #f39c12;
            color: white;
        }

        .boss-details {
            display: flex;
            gap: 8px;
            font-size: 0.75rem;
            color: #7f8c8d;
            align-items: center;
            flex-wrap: wrap;
        }

        .boss-right {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
        }

        .timer-display {
            font-size: 0.9rem;
            font-weight: 700;
            text-align: center;
            padding: 4px 8px;
            border-radius: 4px;
            background: #2c3e50;
            color: white;
            font-family: 'Courier New', monospace;
            min-width: 70px;
            white-space: nowrap;
        }

        .timer-display.respawn-soon {
            background: #f39c12;
            animation: blink 1s infinite;
        }

        .timer-display.unregistered {
            background: #e67e22;
            color: white;
        }

        @keyframes blink {
            50% { opacity: 0.5; }
        }

        .boss-actions {
            display: flex;
            gap: 4px;
            flex-shrink: 0;
        }

        .empty-state {
            text-align: center;
            padding: 30px;
            color: #7f8c8d;
        }

        .notification {
            position: fixed;
            top: 12px;
            right: 12px;
            background: #27ae60;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            font-weight: 600;
            font-size: 0.85rem;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        @media (max-width: 768px) {
            .container {
                padding: 8px;
            }
            .form-row {
                grid-template-columns: 1fr;
                gap: 6px;
                flex-wrap: wrap !important;
            }
            .add-boss-form .form-row .form-group {
                min-width: 100% !important;
                flex: 1 1 100%;
            }
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
            .boss-card {
                flex-direction: column;
                gap: 4px;
                text-align: left;
                min-height: auto;
                padding: 6px 8px;
            }
            .boss-left {
                flex-direction: row;
                gap: 6px;
                width: 100%;
                flex-wrap: wrap;
                align-items: center;
            }
            .boss-name {
                font-size: 0.9rem;
                min-width: 80px;
                flex: 0 0 auto;
            }
            .boss-status {
                font-size: 0.55rem;
                padding: 1px 4px;
            }
            .boss-details {
                justify-content: flex-start;
                gap: 6px;
                font-size: 0.7rem;
                flex: 1;
            }
            .boss-right {
                flex-direction: row;
                gap: 6px;
                width: 100%;
                justify-content: space-between;
                align-items: center;
            }
            .timer-display {
                font-size: 0.8rem;
                padding: 3px 6px;
                min-width: 60px;
            }
            .boss-actions {
                gap: 3px;
            }
            .btn-small {
                padding: 3px 6px;
                font-size: 0.65rem;
            }
            .header h1 {
                font-size: 1.4rem;
            }
            /* 고정보스 등록폼 시/분 입력란 한 줄 배치 */
            #fixedBossForm .form-row,
            #bossForm .boss-form-row {
                flex-wrap: wrap;
                display: flex;
                gap: 8px;
                align-items: flex-end;
            }
            #fixedBossForm .form-row .form-group-hour-minute {
                display: flex;
                flex-direction: row;
                gap: 6px;
                min-width: 120px;
                flex: 0 0 auto;
                align-items: flex-end;
            }
            #fixedBossForm .form-row .form-group-hour-minute label {
                margin-bottom: 0;
            }
            #bossForm .boss-form-row .form-group {
                min-width: 120px;
                flex: 1 1 120px;
            }
            #bossForm .boss-form-row button {
                min-width: 100px;
                margin-top: 20px;
            }
        }

        /* 모달 스타일 */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(3px);
        }

        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 25px;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            position: relative;
            animation: modalSlideIn 0.3s ease;
            }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e9ecef;
        }

        .modal-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 1.2rem;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #999;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
                justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .close-btn:hover {
            background: #f8f9fa;
            color: #333;
        }

        .modal-body {
            text-align: center;
        }

        .modal-body p {
            color: #7f8c8d;
            margin-bottom: 20px;
        }

        .modal-inputs {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
        }

        .modal-inputs input {
            padding: 12px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .modal-inputs input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .modal-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            transition: all 0.3s ease;
        }

        .modal-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        /* 스타일 강조 추가 */
        .stat-card.selected {
            background: linear-gradient(90deg, #667eea 60%, #764ba2 100%);
            color: #fff;
            border: 2.5px solid #3b4cca;
            box-shadow: 0 0 16px #667eea66, 0 2px 12px #764ba244;
            transform: scale(1.07);
            z-index: 2;
            transition: all 0.18s cubic-bezier(0.4,0,0.2,1);
            position: relative;
        }
        .stat-card.selected .stat-number, .stat-card.selected .stat-label {
            color: #fff;
            text-shadow: 0 2px 8px #3b4cca55;
        }

        .weekday-selector {
            display: flex;
            gap: 8px;
            margin: 8px 0;
                flex-wrap: wrap;
            }

        .weekday-checkbox {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .weekday-checkbox input[type="checkbox"] {
            width: auto;
        }

        .weekday-checkbox label {
            font-size: 0.85rem;
            margin: 0;
            cursor: pointer;
        }

        .fixed-boss-options {
            background: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            border: 1px solid #e9ecef;
        }

        .fixed-time-inputs {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-top: 8px;
        }

        .fixed-time-inputs input {
            width: 60px;
            text-align: center;
        }

        /* 모든 입력 필드에서 number 타입 특성 완전히 제거 */
        input {
            -webkit-appearance: none !important;
            -moz-appearance: textfield !important;
            appearance: textfield !important;
        }
        
        /* 스핀 버튼 완전 제거 */
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none !important;
            margin: 0 !important;
            display: none !important;
        }
        
        /* Firefox number 입력 화살표 제거 */
        input[type="number"] {
            -moz-appearance: textfield !important;
            appearance: textfield !important;
        }

        /* 시간 입력 필드 스타일 직접 지정 */
        #editRespawnHours, #editRespawnMinutes,
        #respawnHours, #respawnMinutes,
        #fixedHour, #fixedMinute,
        #editFixedHour, #editFixedMinute {
            -webkit-appearance: none !important;
            -moz-appearance: textfield !important;
            appearance: textfield !important;
            width: 60px;
            text-align: center;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 4px;
        }

        /* TTS 토글 버튼 스타일 */
        #ttsToggle {
            position: absolute;
            top: 8px;
            left: 12px;
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            background: rgba(255,255,255,0.2);
            transition: all 0.2s;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="login-status" id="loginStatus">
                <!-- 로그인 상태 표시 영역 -->
            </div>

            <h1>⚔️ 게임 보스 리젠 타이머 Ver1.5</h1>
            <p style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                보스 몬스터의 리젠 시간을 추적하고 관리하세요
                <button id="helpIcon" title="설명서 보기" style="background: #f4f6fa; border: 1px solid #bfc4c9; border-radius: 16px; font-size: 0.78rem; color: #2563eb; font-weight: 600; padding: 2px 14px 2px 8px; display: flex; align-items: center; gap: 4px; box-shadow: 0 1px 4px rgba(0,0,0,0.04); transition: background 0.2s, color 0.2s; height: 28px; line-height: 1.1;">
                  <span style="font-size:1.1em;">ℹ️</span> 설명서
                </button>
            </p>
        </div>

        <!-- 설명서 모달 -->
        <div id="helpModal" class="modal" style="display:none; position:fixed; z-index:9999; left:0; top:0; width:100vw; height:100vh; background:rgba(0,0,0,0.25); backdrop-filter: blur(2px);">
          <div class="modal-content" style="max-width:520px; margin:60px auto; background:#fff; border-radius:12px; padding:16px 18px 12px 18px; position:relative; box-shadow:0 4px 24px rgba(0,0,0,0.13);">
            <button id="closeHelpModal" style="position:absolute; top:10px; right:14px; background:none; border:none; font-size:1.25rem; color:#888; cursor:pointer;">&times;</button>
            <h2 style="margin:0 0 8px 0; font-size:1.05rem; color:#2563eb; font-weight:700; letter-spacing:-1px;">ℹ️ 사용 설명서</h2>
            <pre id="helpText" style="white-space:pre-wrap; font-size:0.75rem; max-height:56vh; overflow-y:auto; background:#f8f9fa; border-radius:7px; padding:10px 12px; line-height:1.45; color:#222; border:1px solid #e3e6ea;">불러오는 중...</pre>
          </div>
        </div>

        <!-- 로그인 모달 -->
        <div id="loginModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
            <h3>🔐 관리자 로그인</h3>
                    <button class="close-btn" onclick="closeLoginModal()">&times;</button>
                </div>
                <div class="modal-body">
                    <p>보스 추가/삭제를 위해 관리자 로그인이 필요합니다</p>
                    <div class="modal-inputs">
                        <input type="email" id="modalLoginEmail" placeholder="이메일" required>
                        <input type="password" id="modalLoginPassword" placeholder="비밀번호" required>
                    </div>
                    <button type="button" class="modal-btn" onclick="login()">로그인</button>
                </div>
            </div>
        </div>

        <!-- 보스 수정 모달 -->
        <div id="editBossModal" class="modal">
            <div class="modal-content">
                <h2>보스 정보 수정</h2>
                <div class="form-group">
                    <label for="editBossName">보스 이름</label>
                    <input type="text" id="editBossName" placeholder="보스 이름">
                </div>
                <div class="form-group">
                    <label for="editBossLocation">위치</label>
                    <input type="text" id="editBossLocation" placeholder="위치">
                </div>
                
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="editIsFixedBoss"> 고정 보스
                    </label>
                </div>

                <div id="editFixedBossOptions" class="fixed-boss-options" style="display: none;">
                    <div class="weekday-selector">
                        <div class="weekday-checkbox">
                            <input type="checkbox" id="editDay0"><label for="editDay0">일</label>
                        </div>
                        <div class="weekday-checkbox">
                            <input type="checkbox" id="editDay1"><label for="editDay1">월</label>
                        </div>
                        <div class="weekday-checkbox">
                            <input type="checkbox" id="editDay2"><label for="editDay2">화</label>
                        </div>
                        <div class="weekday-checkbox">
                            <input type="checkbox" id="editDay3"><label for="editDay3">수</label>
                        </div>
                        <div class="weekday-checkbox">
                            <input type="checkbox" id="editDay4"><label for="editDay4">목</label>
                        </div>
                        <div class="weekday-checkbox">
                            <input type="checkbox" id="editDay5"><label for="editDay5">금</label>
                        </div>
                        <div class="weekday-checkbox">
                            <input type="checkbox" id="editDay6"><label for="editDay6">토</label>
                        </div>
                    </div>
                    <div class="fixed-time-inputs">
                        <input type="text" id="editFixedHour" placeholder="시">
                        <span>:</span>
                        <input type="text" id="editFixedMinute" placeholder="분">
                    </div>
                </div>

                <div id="editNormalBossOptions">
                    <div class="form-group">
                        <label>리젠 시간</label>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <input type="text" id="editRespawnHours" placeholder="시간" style="width: 80px;">
                            <span>시간</span>
                            <input type="text" id="editRespawnMinutes" placeholder="분" style="width: 80px;">
                            <span>분</span>
                        </div>
                    </div>
                </div>

                <div class="modal-buttons">
                    <button onclick="saveEditBoss()" class="btn">저장</button>
                    <button onclick="closeEditModal()" class="btn" style="background: #6c757d;">취소</button>
                </div>
            </div>
        </div>

        <div class="stats">
            <div class="stat-card" id="statTotal" onclick="setBossFilter('all')">
                <div class="stat-number" id="totalBosses">0</div>
                <div class="stat-label">총 보스 수</div>
            </div>
            <div class="stat-card" id="statAlive" onclick="setBossFilter('alive')">
                <div class="stat-number" id="aliveBosses">0</div>
                <div class="stat-label">생존 보스</div>
            </div>
            <div class="stat-card" id="statDead" onclick="setBossFilter('dead')">
                <div class="stat-number" id="deadBosses">0</div>
                <div class="stat-label">사망 보스</div>
            </div>
            <div class="stat-card" id="statSoon" onclick="setBossFilter('soon')">
                <div class="stat-number" id="respawnSoon">0</div>
                <div class="stat-label">곧 리젠</div>
            </div>
        </div>

        <div class="control-panel admin-only">
            <div class="add-boss-form">
                <h3 style="margin-bottom: 8px; color: #2c3e50;">새 보스 추가</h3>
                <form id="bossForm">
                    <div class="form-row boss-form-row" style="display: flex; gap: 8px; align-items: flex-end; flex-wrap: nowrap;">
                        <div class="form-group" style="min-width: 180px; flex-grow: 1;">
                        <label for="bossName">보스 이름</label>
                            <input type="text" id="bossName" placeholder="예: 드래곤 킹" required style="width: 100%;">
                    </div>
                        <div class="form-group" style="min-width: 120px;">
                            <label for="respawnTime">리젠 시간</label>
                            <div style="display: flex; gap: 5px; align-items: center;">
                                <input type="text" id="respawnHours" placeholder="0" value="0" style="text-align: center; flex: 1;">
                                <span style="font-size: 0.9rem; color: #7f8c8d;">:</span>
                                <input type="text" id="respawnMinutes" placeholder="0" value="0" style="text-align: center; flex: 1;">
                            </div>
                        </div>
                        <div class="form-group" style="min-width: 160px;">
                        <label for="bossLocation">위치</label>
                        <input type="text" id="bossLocation" placeholder="예: 화산 던전 3층">
                    </div>
                        <button type="submit" class="btn" style="min-width: 100px; margin-top: 20px;">보스 추가</button>
                    </div>
                </form>
            </div>
            <!-- 고정보스 등록 폼 -->
            <div class="add-boss-form" style="margin-top: 18px;">
                <h3 style="margin-bottom: 8px; color: #2c3e50;">고정보스 등록</h3>
                <form id="fixedBossForm">
                    <div class="form-row boss-form-row" style="display: flex; gap: 8px; align-items: flex-end; flex-wrap: nowrap;">
                        <div class="form-group" style="min-width: 180px; flex-grow: 1;">
                            <label for="fixedBossName">보스 이름</label>
                            <input type="text" id="fixedBossName" placeholder="예: 드래곤 킹" required style="width: 100%;">
                        </div>
                        <div class="form-group" style="min-width: 120px;">
                            <label for="fixedRespawnTime">출현 시간</label>
                            <div style="display: flex; gap: 5px; align-items: center;">
                                <input type="text" id="fixedHour" placeholder="0" value="0" style="text-align: center; flex: 1;">
                                <span style="font-size: 0.9rem; color: #7f8c8d;">:</span>
                                <input type="text" id="fixedMinute" placeholder="0" value="0" style="text-align: center; flex: 1;">
                            </div>
                        </div>
                        <div class="form-group" style="min-width: 160px;">
                            <label for="fixedLocation">위치</label>
                            <input type="text" id="fixedLocation" placeholder="예: 화산 던전 3층">
                        </div>
                        <button type="submit" class="btn" style="min-width: 100px; margin-top: 20px;">보스 등록</button>
                    </div>
                    <div class="form-row" style="margin-top: 8px;">
                        <div class="form-group" style="min-width: 300px;">
                            <label>출현 요일</label>
                            <div class="weekday-selector" style="margin: 0;">
                                <div class="weekday-checkbox"><input type="checkbox" id="fixedDay0"><label for="fixedDay0">일</label></div>
                                <div class="weekday-checkbox"><input type="checkbox" id="fixedDay1"><label for="fixedDay1">월</label></div>
                                <div class="weekday-checkbox"><input type="checkbox" id="fixedDay2"><label for="fixedDay2">화</label></div>
                                <div class="weekday-checkbox"><input type="checkbox" id="fixedDay3"><label for="fixedDay3">수</label></div>
                                <div class="weekday-checkbox"><input type="checkbox" id="fixedDay4"><label for="fixedDay4">목</label></div>
                                <div class="weekday-checkbox"><input type="checkbox" id="fixedDay5"><label for="fixedDay5">금</label></div>
                                <div class="weekday-checkbox"><input type="checkbox" id="fixedDay6"><label for="fixedDay6">토</label></div>
                            </div>
                        </div>
                    </div>
                </form>
            </div>
            <!-- 설정 영역: 전체 리젠 버튼만 별도 배치 -->
            <div class="add-boss-form" style="margin-top: 18px;">
                <h3 style="margin-bottom: 8px; color: #2c3e50;">설정</h3>
                <div style="display: flex; gap: 8px; align-items: flex-end;">
                    <button type="button" class="btn" onclick="reviveAllBosses()" style="min-width: 120px; background: linear-gradient(45deg, #27ae60, #2ecc71);">🔄 전체 리젠</button>
                </div>
            </div>
        </div>

        <!-- 빠른 처치 입력 -->
        <div id="quickKillSection" style="margin-bottom: 15px; display: none;">
            <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; border: 1px solid #e9ecef;">
                <h4 style="margin: 0 0 8px 0; color: #2c3e50; font-size: 0.9rem;">⚡ 빠른 처치</h4>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <input type="text" id="quickKillInput" placeholder="보스이름 ㅋ (예: 타우록스 ㅋ)" 
                           style="flex: 1; padding: 8px; border: 1px solid #e9ecef; border-radius: 6px; font-size: 0.9rem;">
                    <button type="button" class="btn btn-small" onclick="processQuickKill()">입력</button>
                </div>
                <small style="color: #7f8c8d; font-size: 0.75rem; display: block; margin-top: 4px;">
                    💡 "보스이름 ㅋ" 또는 "[시간] 보스이름 ㅋ" 형태로 입력하세요<br>
                    ⏰ 시간 형식: HHMMSS 또는 HHMM (예: 235959 또는 2359)<br>
                    📝 보스 이름은 앞 2글자 이상 입력 (하드보스는 반드시 '하드'로 끝나야 함)
                </small>
            </div>
        </div>

        <div id="bossContainer">
            <div class="empty-state">
                <h3>등록된 보스가 없습니다</h3>
                <p>위의 양식을 사용해서 첫 번째 보스를 추가해보세요!</p>
            </div>
        </div>
    </div>

    <script>
        console.log('스크립트 시작');
        
        // Firebase SDK 로드 확인
        if (typeof firebase === 'undefined') {
            console.error('Firebase SDK가 로드되지 않았습니다.');
            alert('Firebase 연결에 문제가 있습니다. 페이지를 새로고침해주세요.');
        } else {
            console.log('Firebase SDK 로드 완료');
        }

        // Firebase 설정
        const firebaseConfig = {
            apiKey: "AIzaSyAY6Ff6uZ-iZ7soeuXBU0mtTKKZZ8gAPck",
            authDomain: "bossraidtracker.firebaseapp.com",
            databaseURL: "https://bossraidtracker-default-rtdb.firebaseio.com",
            projectId: "bossraidtracker",
            storageBucket: "bossraidtracker.appspot.com",
            messagingSenderId: "975753692062",
            appId: "1:975753692062:web:0991fb5bcbc52a9d3d0c8f",
            measurementId: "G-MC8YY38ZP3"
        };

        let db, bossTimersRef;
        let bosses = [];
        let timers = {};
        let isLoggedIn = localStorage.getItem('adminLoggedIn') === 'true';
        let currentEditingBoss = null;
        let audioContext = null;
        let soundEnabled = localStorage.getItem('soundEnabled') !== 'false'; // 기본값 true
        let bossFilter = 'all';

        let previousButtonStates = {};
        let isBossDataLoaded = false;

        const ADMIN_EMAIL = 'dogfightda@gmail.com';
        const ADMIN_PASSWORD = '0716';

        // Firebase 초기화
        try {
            console.log('Firebase 초기화 시작');
            firebase.initializeApp(firebaseConfig);
            db = firebase.database();
            bossTimersRef = db.ref('bossTimers');
            
            // Firebase 데이터 로드 및 실시간 업데이트 설정
            let previousBossStates = {};
            bossTimersRef.on('value', (snapshot) => {
                const data = snapshot.val() || {};
                const newBosses = Object.keys(data).map(key => ({
                    id: parseInt(key),
                    ...data[key]
                }));

                // dead → alive로 바뀐 보스만 TTS 실행
                newBosses.forEach(boss => {
                    const prev = previousBossStates[boss.id];
                    if (prev && prev.status === 'dead' && boss.status === 'alive') {
                        if (soundEnabled && isBossDataLoaded) speak(`${boss.name} 보스가 리젠되었습니다.`);
                    }
                    previousBossStates[boss.id] = { status: boss.status };
                });

                bosses = newBosses;
                isBossDataLoaded = true;
                renderBosses();
            }, (error) => {
                console.error('Firebase 데이터 로드 실패:', error);
            });
            
            console.log('Firebase 초기화 완료');
        } catch (error) {
            console.error('Firebase 초기화 실패:', error);
            alert('Firebase 초기화에 실패했습니다: ' + error.message);
        }

        // 리젠/처치 알림음 재생 함수들은 제거하고 TTS만 사용

        // 초기화
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOMContentLoaded 이벤트 발생');
            
            try {
            updateLoginStatus();
                console.log('로그인 상태 업데이트 완료');
                
                if (bossTimersRef) {
                    setupFirebaseListeners();
                    console.log('Firebase 데이터 로드 시작');
                } else {
                    console.error('bossTimersRef가 초기화되지 않았습니다');
                }
                
            startTimers();
                console.log('타이머 시작 완료');
                
                // 빠른 처치 입력 필드 이벤트 등록
                setupQuickKillInput();
                console.log('빠른 처치 입력 설정 완료');
                
                // 사운드 버튼 초기화
                updateSoundButton();
                
                setBossFilter('all'); // 기본값 전체 보스
                
                // 테스트 음성 재생
                setTimeout(() => {
                    // 안드로이드 WebView 환경인지 userAgent로도 한 번 더 체크
                    const isAndroidWebView = /wv/.test(navigator.userAgent) || (window.android && typeof window.android.speak === 'function');
                    if (!isAndroidWebView) {
                        speak('보스 타이머가 준비되었습니다.');
                    }
                }, 1000);
            } catch (error) {
                console.error('초기화 중 에러 발생:', error);
                alert('초기화 중 문제가 발생했습니다: ' + error.message);
            }
        });

        // Firebase 리스너 설정
        function setupFirebaseListeners() {
            if (!bossTimersRef) return;
            
            let previousData = null;
            
            bossTimersRef.on('value', (snapshot) => {
                const data = snapshot.val() || {};
                
                // 데이터가 실제로 변경되었는지 확인
                const currentDataString = JSON.stringify(data);
                if (currentDataString === previousData) {
                    return; // 변경사항이 없으면 렌더링 스킵
                }
                previousData = currentDataString;
                
                bosses = Object.keys(data).map(key => ({
                    id: parseInt(key),
                    ...data[key]
                }));
                
                console.log('Firebase에서 보스 데이터 로드됨:', bosses.length, '개');
                renderBosses();
            });
        }

        // 빠른 처치 입력 설정 함수
        function setupQuickKillInput() {
            const quickKillInput = document.getElementById('quickKillInput');
            console.log('quickKillInput 요소:', quickKillInput);
            
            if (quickKillInput) {
                console.log('엔터키 이벤트 리스너 등록');
                quickKillInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        
                        // 입력 버튼 시각적 효과
                        const inputButton = document.querySelector('#quickKillSection button');
                        if (inputButton) {
                            inputButton.style.transform = 'translateY(1px)';
                            inputButton.style.boxShadow = '0 1px 3px rgba(102, 126, 234, 0.2)';
                            
                            setTimeout(() => {
                                inputButton.style.transform = '';
                                inputButton.style.boxShadow = '';
                            }, 150);
                        }
                        
                        processQuickKill();
                    }
                });
                
                // 입력 필드 포커스 시 시각적 피드백
                quickKillInput.addEventListener('focus', function() {
                    this.style.borderColor = '#667eea';
                    this.style.boxShadow = '0 0 0 2px rgba(102, 126, 234, 0.1)';
                });
                
                quickKillInput.addEventListener('blur', function() {
                    this.style.borderColor = '#e9ecef';
                    this.style.boxShadow = '';
                });
            } else {
                console.error('quickKillInput 요소를 찾을 수 없습니다');
            }
        }

        // 로그인 모달 관련 함수들
        function showLoginModal() {
            document.getElementById('loginModal').style.display = 'block';
            document.getElementById('modalLoginEmail').focus();
        }

        function closeLoginModal() {
            document.getElementById('loginModal').style.display = 'none';
            document.getElementById('modalLoginEmail').value = '';
            document.getElementById('modalLoginPassword').value = '';
        }

        // 모달 외부 클릭 시 닫기
        window.onclick = function(event) {
            const loginModal = document.getElementById('loginModal');
            const editModal = document.getElementById('editBossModal');
            if (event.target === loginModal) {
                closeLoginModal();
            } else if (event.target === editModal) {
                closeEditModal();
            }
        }

        // ESC 키로 모달 닫기
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeLoginModal();
                closeEditModal();
            }
        });

        // 모달에서 Enter 키로 로그인/저장
        document.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                const loginModal = document.getElementById('loginModal');
                const editModal = document.getElementById('editBossModal');
                if (loginModal.style.display === 'block') {
                    login();
                } else if (editModal.style.display === 'block') {
                    saveEditBoss();
                }
            }
        });

        // 로그인 함수
        function login() {
            const email = document.getElementById('modalLoginEmail').value;
            const password = document.getElementById('modalLoginPassword').value;

            if (email === ADMIN_EMAIL && password === ADMIN_PASSWORD) {
                isLoggedIn = true;
                localStorage.setItem('adminLoggedIn', 'true');
                updateLoginStatus();
                closeLoginModal();
                showNotification('관리자로 로그인되었습니다!');
            } else {
                showNotification('이메일 또는 비밀번호가 잘못되었습니다.');
            }
        }

        // 로그아웃 함수
        function logout() {
            isLoggedIn = false;
            localStorage.removeItem('adminLoggedIn');
            updateLoginStatus();
            showNotification('로그아웃되었습니다.');
        }

        // 로그인 상태 업데이트
        function updateLoginStatus() {
            const loginStatus = document.getElementById('loginStatus');
            const container = document.querySelector('.container');

            if (isLoggedIn) {
                loginStatus.innerHTML = `
                    <div class="user-info">관리자</div>
                    <button class="logout-btn" onclick="logout()">로그아웃</button>
                `;
                container.classList.add('admin-logged-in');
            } else {
                loginStatus.innerHTML = `
                    <div class="user-info">게스트 모드</div>
                    <button class="login-btn" onclick="showLoginModal()">관리자</button>
                `;
                container.classList.remove('admin-logged-in');
            }
        }

        // 보스 추가 폼
        document.getElementById('bossForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const hours = parseInt(document.getElementById('respawnHours').value) || 0;
            const minutes = parseInt(document.getElementById('respawnMinutes').value) || 0;
            const totalMinutes = hours * 60 + minutes;
            
            if (totalMinutes <= 0) {
                showNotification('리젠 시간을 입력해주세요.');
                return;
            }
            
            if (hours > 48) {
                showNotification('리젠 시간은 최대 48시간까지 입력 가능합니다.');
                return;
            }
            
            const bossData = {
                id: Date.now(),
                name: document.getElementById('bossName').value,
                respawnTime: totalMinutes,
                location: document.getElementById('bossLocation').value || '미설정',
                status: 'alive',
                lastKilled: null,
                nextRespawn: null,
                unregistered: false,
                autoProcessed: false,
                createdAt: new Date().toISOString()
            };

            // Firebase에 보스 데이터 저장
            bossTimersRef.child(bossData.id.toString()).set(bossData)
                .then(() => {
                    document.getElementById('bossForm').reset();
                    document.getElementById('respawnHours').value = '0';
                    document.getElementById('respawnMinutes').value = '0';
                    showNotification(`${bossData.name} 보스가 추가되었습니다!`);
                })
                .catch((error) => {
                    console.error('보스 추가 실패:', error);
                    showNotification('보스 추가에 실패했습니다.');
                });
        });

        // 리젠 시간 입력 필드 이벤트 핸들러
        document.getElementById('respawnHours').addEventListener('input', function(e) {
            let value = parseInt(e.target.value) || 0;
            if (isNaN(value) || value < 0) value = 0;
            if (value > 48) value = 48;
            e.target.value = value;
        });

        document.getElementById('respawnMinutes').addEventListener('input', function(e) {
            let value = parseInt(e.target.value) || 0;
            if (isNaN(value) || value < 0) value = 0;
            if (value > 59) value = 59;
            e.target.value = value;
        });

        document.getElementById('editRespawnHours').addEventListener('input', function(e) {
            let value = parseInt(e.target.value) || 0;
            if (isNaN(value) || value < 0) value = 0;
            if (value > 48) value = 48;
            e.target.value = value;
        });

        document.getElementById('editRespawnMinutes').addEventListener('input', function(e) {
            let value = parseInt(e.target.value) || 0;
            if (isNaN(value) || value < 0) value = 0;
            if (value > 59) value = 59;
            e.target.value = value;
        });

        // 보스 렌더링 (Firebase 리스너 전용)
        function renderBosses() {
            if (!isBossDataLoaded) return;
            renderBossesUI();
            updateStats();
        }
            
        // 보스 목록 렌더링 (Firebase 리스너 전용)
        function renderBossesUI() {
            if (!isBossDataLoaded) return;
            const container = document.getElementById('bossContainer');
            const quickKillSection = document.getElementById('quickKillSection');
            if (bosses.length === 0) {
                container.innerHTML = '<div class="empty-state"><h3>등록된 보스가 없습니다</h3><p>위의 양식을 사용해서 첫 번째 보스를 추가해보세요!</p></div>';
                quickKillSection.style.display = 'none';
                return;
            }
            quickKillSection.style.display = 'block';
            let filteredBosses = bosses;
            if (bossFilter === 'alive') {
                const now = new Date();
                filteredBosses = bosses.filter(b => {
                    // 생존 상태인 보스
                    if (b.status === 'alive') return true;
                    
                    // 일반 보스의 곧 리젠 상태 확인
                    if (b.status === 'dead' && b.nextRespawn) {
                        const time = new Date(b.nextRespawn) - now;
                        if (time > 0 && time <= 600000) return true;
                    }
                    
                    // 고정 보스의 곧 리젠 상태 확인
                    if (b.fixed) {
                        let minNextDiff = 7 * 24 * 60;
                        b.fixedDays.forEach(day => {
                            let diff = (day - now.getDay()) * 24 * 60 
                                + (b.fixedHour - now.getHours()) * 60 
                                + (b.fixedMinute - now.getMinutes());
                            if (diff <= 0) diff += 7 * 24 * 60;
                            minNextDiff = Math.min(minNextDiff, diff);
                        });
                        if (minNextDiff * 60 * 1000 <= 600000) return true;
                    }
                    
                    return false;
                });
            } else if (bossFilter === 'dead') {
                filteredBosses = bosses.filter(b => b.status === 'dead');
            } else if (bossFilter === 'soon') {
                filteredBosses = bosses.filter(b => b.status === 'dead' && b.nextRespawn && (new Date(b.nextRespawn) - new Date() > 0) && (new Date(b.nextRespawn) - new Date() <= 600000));
            }
            const sortedBosses = [...filteredBosses].sort((a, b) => {
                const now = new Date();

                // 보스의 다음 리젠/상태 시간을 계산하는 함수
                function getNextTime(boss) {
                    if (boss.status === 'alive') {
                        return Infinity;  // 살아있는 보스는 최상단
                    }

                    const now = new Date();
                    
                    if (boss.fixed) {
                        // 고정보스의 다음 리젠 시간 계산
                        const nowDay = now.getDay();
                        const nowHour = now.getHours();
                        const nowMinute = now.getMinutes();
                        let minNextDiff = 7 * 24 * 60;
                        
                        boss.fixedDays.forEach(day => {
                            let diff = (day - nowDay) * 24 * 60 
                                + (boss.fixedHour - nowHour) * 60 
                                + (boss.fixedMinute - nowMinute);
                            if (diff <= 0) diff += 7 * 24 * 60;
                            minNextDiff = Math.min(minNextDiff, diff);
                        });
                        
                        const nextTime = minNextDiff * 60 * 1000;  // 밀리초 단위로 변환
                        return nextTime;
                    }

                    if (boss.status === 'dead' && boss.nextRespawn) {
                        const time = new Date(boss.nextRespawn) - now;
                        return time > 0 ? time : 0;
                    }

                    return 9999999999;  // 기타 상태는 맨 아래로
                }

                const timeA = getNextTime(a);
                const timeB = getNextTime(b);

                // 둘 다 대기중인 경우 이름순으로 정렬
                if (timeA === Infinity && timeB === Infinity) {
                    // 고정보스를 일반보스보다 위에 배치
                    if (a.fixed && !b.fixed) return -1;
                    if (!a.fixed && b.fixed) return 1;
                    return a.name.localeCompare(b.name, 'ko');
                }

                // 대기중인 보스가 최상단에 오도록
                if (timeA === Infinity) return -1;
                if (timeB === Infinity) return 1;

                // 남은 시간이 적은 순서대로 정렬
                if (timeA !== timeB) return timeA - timeB;

                // 시간이 같은 경우 고정보스를 위에 배치
                if (a.fixed && !b.fixed) return -1;
                if (!a.fixed && b.fixed) return 1;

                // 그 외의 경우 이름순
                return a.name.localeCompare(b.name, 'ko');
            });
            
            // 상태 변화 감지 및 사운드 안내
            bosses.forEach(boss => {
                const prev = previousButtonStates[boss.id];
                // TTS 호출 제거 (중복 방지)
                previousButtonStates[boss.id] = { status: boss.status };
            });

            container.innerHTML = `
                <div class="boss-grid">
                    ${sortedBosses.map(boss => createBossCard(boss)).join('')}
                </div>
            `;
        }

        // 보스 카드 생성
        function createBossCard(boss) {
            const now = new Date();
            let statusClass = 'alive';
            let statusText = '생존';
            let timerDisplay = '대기 중';
            let isUnregistered = false;
            
            // 리젠 시간을 시간:분 형태로 표시
            let timeDisplay = '';
            if (boss.fixed) {
                const dayNames = ['일', '월', '화', '수', '목', '금', '토'];
                const fixedDaysText = boss.fixedDays.map(day => dayNames[day]).join(', ');
                timeDisplay = `<span>📅 ${fixedDaysText}요일 ${boss.fixedHour.toString().padStart(2, '0')}:${boss.fixedMinute.toString().padStart(2, '0')}</span>`;
            } else {
                const respawnHours = Math.floor(boss.respawnTime / 60);
                const respawnMins = boss.respawnTime % 60;
                timeDisplay = `<span>⏱️ ${respawnHours > 0 ? `${respawnHours}시간 ${respawnMins}분` : `${respawnMins}분`}</span>`;
            }
            
            // 카드 하단에 항상 마지막 컷 시간 표기 (24시간제, NaN 방지)
            let lastKilledDisplay = '';
            if (boss.fixed) {
                // 고정보스는 가장 최근의 리젠 시각(요일/시/분) 표기
                const now = new Date();
                const nowDay = now.getDay();
                const nowHour = now.getHours();
                const nowMinute = now.getMinutes();
                
                // 다음 리젠 요일/시/분 (항상 미래)
                let minNextDiff = 7 * 24 * 60;
                let nextDay = nowDay;
                boss.fixedDays.forEach(day => {
                    let diff = (day - nowDay) * 24 * 60 + (boss.fixedHour - nowHour) * 60 + (boss.fixedMinute - nowMinute);
                    if (diff <= 0) diff += 7 * 24 * 60;
                    if (diff < minNextDiff) {
                        minNextDiff = diff;
                        nextDay = day;
                    }
                });
                
                // 가장 최근 리젠 시각 계산
                let minDiff = 7 * 24 * 60;
                let lastDay = nowDay;
                boss.fixedDays.forEach(day => {
                    let diff = (nowDay - day) * 24 * 60 + (nowHour - boss.fixedHour) * 60 + (nowMinute - boss.fixedMinute);
                    if (diff < 0) diff += 7 * 24 * 60;
                    if (diff < minDiff) {
                        minDiff = diff;
                        lastDay = day;
                    }
                });
                
                const lastRegen = new Date(now);
                lastRegen.setDate(now.getDate() - ((nowDay - lastDay + 7) % 7));
                lastRegen.setHours(boss.fixedHour);
                lastRegen.setMinutes(boss.fixedMinute);
                lastRegen.setSeconds(0);

                const nextRegen = new Date(now);
                nextRegen.setDate(now.getDate() + ((nextDay - nowDay + 7) % 7));
                nextRegen.setHours(boss.fixedHour);
                nextRegen.setMinutes(boss.fixedMinute);
                nextRegen.setSeconds(0);
                
                if (!isNaN(lastRegen.getTime())) {
                    const hour = lastRegen.getHours().toString().padStart(2, '0');
                    const min = lastRegen.getMinutes().toString().padStart(2, '0');
                    const sec = lastRegen.getSeconds().toString().padStart(2, '0');
                    
                    const nextHour = nextRegen.getHours().toString().padStart(2, '0');
                    const nextMin = nextRegen.getMinutes().toString().padStart(2, '0');
                    const nextSec = nextRegen.getSeconds().toString().padStart(2, '0');
                    
                    lastKilledDisplay = `<span>🗡️ 마지막 컷: ${hour}:${min}:${sec}</span><span style="margin-left: 10px;">⏰ 다음 리젠: ${nextHour}:${nextMin}:${nextSec}</span>`;
                }
            } else if (boss.lastKilled) {
                const killedTime = new Date(boss.lastKilled);
                if (!isNaN(killedTime.getTime())) {
                    const hour = killedTime.getHours().toString().padStart(2, '0');
                    const min = killedTime.getMinutes().toString().padStart(2, '0');
                    const sec = killedTime.getSeconds().toString().padStart(2, '0');
                    
                    // 리젠 예상 시간 계산
                    const expectedRespawnTime = new Date(killedTime.getTime() + boss.respawnTime * 60000);
                    const respawnHour = expectedRespawnTime.getHours().toString().padStart(2, '0');
                    const respawnMin = expectedRespawnTime.getMinutes().toString().padStart(2, '0');
                    const respawnSec = expectedRespawnTime.getSeconds().toString().padStart(2, '0');
                    
                    lastKilledDisplay = `<span>🗡️ 마지막 컷: ${hour}:${min}:${sec}</span><span style="margin-left: 10px;">⏰ 다음 리젠: ${respawnHour}:${respawnMin}:${respawnSec}</span>`;
                }
            }

            // 고정보스: 다음 리젠까지 남은 시간 계산 및 상태 표시
            if (boss.fixed) {
                // 고정보스 남은 시간 계산 개선
                const nowDay = now.getDay();
                const nowHour = now.getHours();
                const nowMinute = now.getMinutes();
                
                // 다음 리젠 요일/시/분 (항상 미래)
                let minNextDiff = 7 * 24 * 60;
                let nextDay = nowDay;
                boss.fixedDays.forEach(day => {
                    let diff = (day - nowDay) * 24 * 60 + (boss.fixedHour - nowHour) * 60 + (boss.fixedMinute - nowMinute);
                    if (diff <= 0) diff += 7 * 24 * 60;
                    if (diff < minNextDiff) {
                        minNextDiff = diff;
                        nextDay = day;
                    }
                });
                const nextRegen = new Date(now);
                nextRegen.setDate(now.getDate() + ((nextDay - nowDay + 7) % 7));
                nextRegen.setHours(boss.fixedHour);
                nextRegen.setMinutes(boss.fixedMinute);
                nextRegen.setSeconds(0);

                // 상태 판단 로직 개선
                if (boss.status === 'dead') {
                    let diff = nextRegen - now;
                    if (diff < 0) diff += 7 * 24 * 60 * 60 * 1000;
                    if (diff <= 600000) {
                        statusClass = 'respawn-soon';
                        statusText = '곧 리젠';
                    } else if (diff <= 0) {
                    statusClass = 'alive';
                    statusText = '생존';
                        timerDisplay = '대기 중';
                } else {
                        statusClass = 'dead';
                        statusText = '사망';
                    }
                    timerDisplay = diff > 0 ? formatTime(diff) : '대기 중';
                } else if (boss.status === 'alive') {
                    // alive 상태일 때는 상태를 변경하지 않고 대기 중만 표시
                    statusClass = 'alive';
                    statusText = '생존';
                    timerDisplay = '대기 중';
                }
            } else if (boss.status === 'alive') {
                isUnregistered = boss.unregistered || false;
                // lastKilled이 있다면 리젠 시간까지 계산해서 표시
                if (boss.lastKilled) {
                    const killedTime = new Date(boss.lastKilled);
                    const expectedRespawnTime = new Date(killedTime.getTime() + boss.respawnTime * 60000);
                    const timeDiff = expectedRespawnTime - now;
                    if (timeDiff > 0) {
                        // 리젠까지 남은 시간 (미등록이면 미등록 붙임)
                        statusClass = timeDiff <= 600000 ? 'respawn-soon' : 'dead';
                    statusText = timeDiff <= 600000 ? '곧 리젠' : '사망';
                        timerDisplay = formatTime(timeDiff) + (isUnregistered ? ' 미등록' : '');
                    } else {
                        // 리젠 완료 후 대기중
                        statusClass = 'alive';
                        statusText = '생존';
                        timerDisplay = '대기 중';
                    }
                } else {
                    // 컷 기록이 없는 경우 - 진짜 대기중
                    statusText = '생존';
                    timerDisplay = '대기 중';
                }
            } else if (boss.status === 'dead' && boss.nextRespawn) {
                const respawnTime = new Date(boss.nextRespawn);
                const timeDiff = respawnTime - now;
                isUnregistered = boss.unregistered || false;
                if (timeDiff > 0) {
                    statusClass = timeDiff <= 600000 ? 'respawn-soon' : 'dead';
                    statusText = timeDiff <= 600000 ? '곧 리젠' : '사망';
                    timerDisplay = formatTime(timeDiff) + (isUnregistered ? ' 미등록' : '');
                } else {
                    statusClass = 'alive';
                    statusText = '생존';
                    timerDisplay = '대기 중';
                }
            }

            return `
                <div class="boss-card ${statusClass}">
                    <div class="boss-left">
                        <div class="boss-status status-${statusClass === 'respawn-soon' ? 'soon' : statusClass}">
                            ${statusText}
                        </div>
                        <div class="boss-name">${boss.name}
                            ${boss.fixed ? '<span style=\"background:#3b4cca;color:#fff;font-size:0.7em;padding:2px 7px;border-radius:8px;margin-left:6px;vertical-align:middle;\">고정</span>' : ''}
                        </div>
                            <div class="boss-details">
                                <span>📍 ${boss.location}</span>
                            ${timeDisplay}
                            ${lastKilledDisplay}
                            </div>
                        </div>
                    <div class="boss-right">
                        <div class="timer-display ${statusClass === 'respawn-soon' ? 'respawn-soon' : ''} ${isUnregistered ? 'unregistered' : ''}" id="timer-${boss.id}">
                            ${timerDisplay}
                        </div>
                    <div class="boss-actions">
                        ${(boss.fixed && statusClass === 'dead') || boss.status === 'dead' ? 
                            `<button class="btn btn-small" onclick="reviveBoss(${boss.id})">리젠</button>` :
                            `<button class="btn btn-kill btn-small" onclick="killBoss(${boss.id})">처치</button>`
                        }
                        <button class="btn btn-small admin-only" onclick="showEditModal(${boss.id})" style="background: #6c757d;">수정</button>
                        <button class="btn btn-small delete-btn" onclick="deleteBoss(${boss.id})">삭제</button>
                    </div>
                    </div>
                </div>
            `;
        }

        // 보스 처치
        function killBoss(id) {
            const boss = bosses.find(b => b.id === id);
            if (!boss) return;
            const now = new Date();
            let updatedBoss;
            if (boss.fixed) {
                // 고정보스의 다음 리젠 시간 계산
                const nowDay = now.getDay();
                const nowHour = now.getHours();
                const nowMinute = now.getMinutes();
                let minNextDiff = 7 * 24 * 60;
                let nextDay = nowDay;
                
                boss.fixedDays.forEach(day => {
                    let diff = (day - nowDay) * 24 * 60 + (boss.fixedHour - nowHour) * 60 + (boss.fixedMinute - nowMinute);
                    if (diff <= 0) diff += 7 * 24 * 60;
                    if (diff < minNextDiff) {
                        minNextDiff = diff;
                        nextDay = day;
                    }
                });
                
                const nextRegen = new Date(now);
                nextRegen.setDate(now.getDate() + ((nextDay - nowDay + 7) % 7));
                nextRegen.setHours(boss.fixedHour);
                nextRegen.setMinutes(boss.fixedMinute);
                nextRegen.setSeconds(0);
                
                updatedBoss = {
                    ...boss,
                    status: 'dead',
                    lastKilled: now.toISOString(),
                    nextRespawn: nextRegen.toISOString(),  // 다음 리젠 시간 설정
                    unregistered: false,
                    autoProcessed: false  // 수동 처치 시에는 false로 설정
                };
            } else {
                updatedBoss = {
                    ...boss,
                    status: 'dead',
                    lastKilled: now.toISOString(),
                    nextRespawn: new Date(now.getTime() + boss.respawnTime * 60000).toISOString(),
                    unregistered: false, // 수동 처치 시 미등록 상태 해제
                    autoProcessed: true
                };
            }
            bossTimersRef.child(id.toString()).update(updatedBoss)
                .then(() => {
                    speak(`${boss.name} 보스를 처치했습니다!`); // TTS 사용
                    showNotification(`${boss.name} 보스를 처치했습니다!`);
                })
                .catch((error) => {
                    console.error('보스 처치 업데이트 실패:', error);
                    showNotification('업데이트에 실패했습니다.');
                });
        }

        // 보스 수동 리젠
        function reviveBoss(id) {
            if (!confirm('정말로 이 보스를 리젠 처리하시겠습니까?')) {
                return;
            }
            const boss = bosses.find(b => b.id === id);
            if (!boss) return;
            
            const updatedBoss = {
                ...boss,
                status: 'alive',
                // 미등록 보스는 lastKilled 유지, 정상 보스는 lastKilled 초기화
                lastKilled: boss.unregistered ? boss.lastKilled : null,
                nextRespawn: null
            };
            
            bossTimersRef.child(id.toString()).update(updatedBoss)
                .then(() => {
                    speak(`${boss.name} 보스가 리젠되었습니다!`); // TTS 사용
                    const statusText = boss.unregistered ? '(미등록 상태 유지)' : '';
                    showNotification(`${boss.name} 보스가 리젠되었습니다!`);
                })
                .catch((error) => {
                    console.error('보스 리젠 업데이트 실패:', error);
                    showNotification('업데이트에 실패했습니다.');
                });
        }

        // 보스 삭제
        function deleteBoss(id) {
            if (!isLoggedIn) {
                showNotification('관리자만 삭제할 수 있습니다.');
                return;
            }
            
            if (confirm('정말로 이 보스를 삭제하시겠습니까?')) {
                bossTimersRef.child(id.toString()).remove()
                    .then(() => {
                showNotification('보스가 삭제되었습니다.');
                    })
                    .catch((error) => {
                        console.error('보스 삭제 실패:', error);
                        showNotification('삭제에 실패했습니다.');
                    });
            }
        }

        // 시간 형식화
        function formatTime(milliseconds) {
            const totalSeconds = Math.floor(milliseconds / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            } else {
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // 타이머 시작 (UI 업데이트만, Firebase 업데이트 없음)
        function startTimers() {
            // UI 업데이트를 1초마다로 변경
            setInterval(() => {
                renderBossesUI();
                updateStats();
            }, 1000);
            // 자동 처리는 10초마다 체크 (Firebase 부하 대폭 감소)
            setInterval(() => {
                checkAutoProcessing();
            }, 1000);
        }

        // 자동 처리 체크 (5분마다만 실행)
        function checkAutoProcessing() {
            const now = new Date();
            const updates = {};
            let hasUpdates = false;
            
            bosses.forEach(boss => {
                // [고정보스 자동 리젠]
                if (boss.fixed) {
                    const nowDay = now.getDay();
                    const nowHour = now.getHours();
                    const nowMinute = now.getMinutes();
                    
                    // 다음 리젠 시각 계산
                    let minNextDiff = 7 * 24 * 60;
                    let nextDay = nowDay;
                    boss.fixedDays.forEach(day => {
                        let diff = (day - nowDay) * 24 * 60 + (boss.fixedHour - nowHour) * 60 + (boss.fixedMinute - nowMinute);
                        if (diff <= 0) diff += 7 * 24 * 60;
                        if (diff < minNextDiff) {
                            minNextDiff = diff;
                            nextDay = day;
                        }
                    });
                    
                    const nextRegen = new Date(now);
                    nextRegen.setDate(now.getDate() + ((nextDay - nowDay + 7) % 7));
                    nextRegen.setHours(boss.fixedHour);
                    nextRegen.setMinutes(boss.fixedMinute);
                    nextRegen.setSeconds(0);

                    // 현재가 리젠 타임인지 확인 (정확히 분단위까지만 체크)
                    const isRegenTime = boss.fixedDays.includes(nowDay) &&
                                      boss.fixedHour === nowHour &&
                                      boss.fixedMinute === nowMinute;

                    // 수동으로 처치된 경우는 자동 처리하지 않음
                    if (!boss.autoProcessed) {
                        if (boss.status === 'dead' && isRegenTime) {
                            // dead 상태에서 리젠 타임이면 alive로 변경
                            updates[`${boss.id}/status`] = 'alive';
                            updates[`${boss.id}/lastKilled`] = null;
                            updates[`${boss.id}/nextRespawn`] = null;
                            updates[`${boss.id}/autoProcessed`] = false;
                            updates[`${boss.id}/unregistered`] = false;
                            hasUpdates = true;
                        } 
                        else if (boss.status === 'alive' && !boss.lastKilled) {
                            // 현재 시간이 리젠 시간으로부터 5분 이상 지났는지 확인
                            const currentMinutes = nowHour * 60 + nowMinute;
                            const regenMinutes = boss.fixedHour * 60 + boss.fixedMinute;
                            let timeSinceRegen = currentMinutes - regenMinutes;
                            
                            // 자정을 넘긴 경우 처리
                            if (timeSinceRegen < -18 * 60) { // 자정을 넘긴 경우 (6시간 이상 차이나면)
                                timeSinceRegen += 24 * 60;
                            }
                            
                            // 리젠 시간으로부터 5분 이상 지났고, 수동 처치되지 않은 경우에만 자동 처치
                            if (timeSinceRegen >= 5) {
                                updates[`${boss.id}/status`] = 'dead';
                                updates[`${boss.id}/lastKilled`] = now.toISOString();
                                updates[`${boss.id}/nextRespawn`] = nextRegen.toISOString();
                                updates[`${boss.id}/autoProcessed`] = true;
                                updates[`${boss.id}/unregistered`] = false;
                                hasUpdates = true;
                            }
                        }
                    }
                }
                // [기존 일반 보스 자동처리 로직]
                // 컷 시간이 있는 보스만 자동 처치 체크
                if (boss.status === 'alive' && boss.lastKilled && !boss.autoProcessed) {
                    const lastKilledTime = new Date(boss.lastKilled);
                    const expectedRespawnTime = new Date(lastKilledTime.getTime() + boss.respawnTime * 60000);
                    const fiveMinutesAfterRespawn = new Date(expectedRespawnTime.getTime() + 5 * 60 * 1000);
                    
                    // 예상 리젠 시간에서 5분이 지났는지 체크
                    if (now >= fiveMinutesAfterRespawn) {
                        console.log(`${boss.name}: 예상 리젠(${expectedRespawnTime.toLocaleString()})에서 5분 경과 -> 자동 컷 처리`);
                        
                        // 예상 리젠 시간에 잡았다고 간주하고 lastKilled 업데이트
                        const newKillTime = expectedRespawnTime;
                        const newRespawnTime = new Date(newKillTime.getTime() + boss.respawnTime * 60000);
                        
                        updates[`${boss.id}/status`] = 'dead';
                        updates[`${boss.id}/lastKilled`] = newKillTime.toISOString();
                        updates[`${boss.id}/nextRespawn`] = newRespawnTime.toISOString();
                        updates[`${boss.id}/autoProcessed`] = true;
                        updates[`${boss.id}/unregistered`] = true;
                        hasUpdates = true;
                        
                        console.log(`${boss.name}: 새로운 컷시간 ${newKillTime.toLocaleString()} -> 다음 리젠 ${newRespawnTime.toLocaleString()}`);
                    }
                }
                
                // 한번도 컷 시간이 없는 보스는 무한 대기 (자동 처치 안됨)
                // if (!boss.lastKilled) -> 아무것도 하지 않음
                
                // alive 상태이지만 lastKilled이 있고 리젠 시간이 지난 경우 처리
                if (boss.status === 'alive' && boss.lastKilled && boss.unregistered) {
                    const killedTime = new Date(boss.lastKilled);
                    const expectedRespawnTime = new Date(killedTime.getTime() + boss.respawnTime * 60000);
                    
                    if (expectedRespawnTime <= now) {
                        // 리젠 시간이 지났으므로 미등록 상태 해제
                        console.log(`${boss.name}: 리젠 시간 완료, 미등록 상태 해제`);
                        updates[`${boss.id}/autoProcessed`] = false;
                        updates[`${boss.id}/unregistered`] = false; // 추가!
                        hasUpdates = true;
                    }
                }
                
                // 리젠 완료 처리 (dead 상태에서 nextRespawn이 있는 경우)
                if (!boss.fixed && boss.status === 'dead' && boss.nextRespawn) {  // 고정보스가 아닌 경우에만 처리
                    const respawnTime = new Date(boss.nextRespawn);
                    if (respawnTime <= now) {
                        updates[`${boss.id}/status`] = 'alive';
                        updates[`${boss.id}/nextRespawn`] = null;
                        updates[`${boss.id}/autoProcessed`] = false;
                        updates[`${boss.id}/unregistered`] = false; // 추가!
                        updates[`${boss.id}/lastKilled`] = null;    // 추가!
                        hasUpdates = true;
                    }
                }
            });
            
            // 업데이트가 있을 때만 Firebase 호출
            if (hasUpdates && bossTimersRef) {
                // 리젠된 보스가 있는지 확인
                const hasRespawns = Object.keys(updates).some(key => key.endsWith('/status') && updates[key] === 'alive');
                
                bossTimersRef.update(updates)
                    .then(() => {
                        console.log('자동 처리 업데이트 완료');
                        // TTS 호출 제거 (Firebase 리스너에서만 실행)
                    })
                    .catch((error) => {
                        console.error('자동 처리 업데이트 실패:', error);
                    });
            }
        }

        // 보스 수정 모달 관련 함수들
        function showEditModal(bossId) {
            const boss = bosses.find(b => b.id === bossId);
            if (!boss) return;
            
            currentEditingBoss = boss;
            
            // 모달에 현재 보스 정보 채우기
            document.getElementById('editBossName').value = boss.name;
            document.getElementById('editBossLocation').value = boss.location;
            
            // 고정보스 여부에 따른 UI 처리
            const isFixedBoss = boss.fixed || false;
            document.getElementById('editIsFixedBoss').checked = isFixedBoss;
            
            if (isFixedBoss) {
                document.getElementById('editFixedBossOptions').style.display = 'block';
                document.getElementById('editNormalBossOptions').style.display = 'none';
                
                // 요일 체크박스 설정
                const days = boss.fixedDays || [];
                for (let i = 0; i < 7; i++) {
                    document.getElementById(`editDay${i}`).checked = days.includes(i);
                }
                
                // 시간 설정
                document.getElementById('editFixedHour').value = boss.fixedHour || '';
                document.getElementById('editFixedMinute').value = boss.fixedMinute || '';
            } else {
                document.getElementById('editFixedBossOptions').style.display = 'none';
                document.getElementById('editNormalBossOptions').style.display = 'block';
                
                // 일반 리젠 시간 설정
                document.getElementById('editRespawnHours').value = Math.floor(boss.respawnTime / 60);
                document.getElementById('editRespawnMinutes').value = boss.respawnTime % 60;
            }
            
            document.getElementById('editBossModal').style.display = 'block';
            document.getElementById('editBossName').focus();
        }

        // 고정보스 체크박스 이벤트 처리
        document.getElementById('editIsFixedBoss').addEventListener('change', function(e) {
            const isFixed = e.target.checked;
            document.getElementById('editFixedBossOptions').style.display = isFixed ? 'block' : 'none';
            document.getElementById('editNormalBossOptions').style.display = isFixed ? 'none' : 'block';
        });

        function saveEditBoss() {
            if (!currentEditingBoss) return;
            
            const isFixed = document.getElementById('editIsFixedBoss').checked;
            let updatedBoss = {
                ...currentEditingBoss,
                name: document.getElementById('editBossName').value.trim(),
                location: document.getElementById('editBossLocation').value.trim() || '미설정',
                fixed: isFixed
            };
            
            if (!updatedBoss.name) {
                showNotification('보스 이름을 입력해주세요.');
                return;
            }
            
            if (isFixed) {
                // 선택된 요일 배열 생성
                const selectedDays = [];
                for (let i = 0; i < 7; i++) {
                    if (document.getElementById(`editDay${i}`).checked) {
                        selectedDays.push(i);
                    }
                }
                
                if (selectedDays.length === 0) {
                    showNotification('최소 하나의 요일을 선택해주세요.');
                    return;
                }
                
                const fixedHour = parseInt(document.getElementById('editFixedHour').value);
                const fixedMinute = parseInt(document.getElementById('editFixedMinute').value);
                
                if (isNaN(fixedHour) || isNaN(fixedMinute) || 
                    fixedHour < 0 || fixedHour > 48 || 
                    fixedMinute < 0 || fixedMinute > 59) {
                    showNotification('올바른 시간을 입력해주세요.');
                    return;
                }
                
                updatedBoss = {
                    ...updatedBoss,
                    fixedDays: selectedDays,
                    fixedHour: fixedHour,
                    fixedMinute: fixedMinute,
                    respawnTime: 0  // 고정보스는 respawnTime 사용 안 함
                };
            } else {
                const hours = parseInt(document.getElementById('editRespawnHours').value) || 0;
                const minutes = parseInt(document.getElementById('editRespawnMinutes').value) || 0;
                const totalMinutes = hours * 60 + minutes;
                
                if (totalMinutes <= 0) {
                    showNotification('리젠 시간을 입력해주세요.');
                    return;
                }
                
                if (hours > 48) {
                    showNotification('리젠 시간은 최대 48시간까지 입력 가능합니다.');
                    return;
                }
                
                updatedBoss = {
                    ...updatedBoss,
                    respawnTime: totalMinutes,
                    fixedDays: null,
                    fixedHour: null,
                    fixedMinute: null
                };
            }
            
            // Firebase에 업데이트
            bossTimersRef.child(currentEditingBoss.id.toString()).update(updatedBoss)
                .then(() => {
                    closeEditModal();
                    showNotification(`${updatedBoss.name} 보스 정보가 수정되었습니다!`);
                })
                .catch((error) => {
                    console.error('보스 수정 실패:', error);
                    showNotification('수정에 실패했습니다.');
                });
        }

        function closeEditModal() {
            document.getElementById('editBossModal').style.display = 'none';
            document.getElementById('editFixedBossOptions').style.display = 'none';
            document.getElementById('editNormalBossOptions').style.display = 'block';
            document.getElementById('editIsFixedBoss').checked = false;
            currentEditingBoss = null;
            
            // 입력 필드 초기화
            document.getElementById('editBossName').value = '';
            document.getElementById('editBossLocation').value = '';
            document.getElementById('editRespawnHours').value = '';
            document.getElementById('editRespawnMinutes').value = '';
            document.getElementById('editFixedHour').value = '';
            document.getElementById('editFixedMinute').value = '';
            
            // 요일 체크박스 초기화
            for (let i = 0; i < 7; i++) {
                document.getElementById(`editDay${i}`).checked = false;
            }
        }

        // 전체 보스 리젠
        function reviveAllBosses() {
            if (!isLoggedIn) {
                showNotification('관리자만 전체 리젠할 수 있습니다.');
                return;
            }
            
            // 고정보스를 제외한 사망 상태의 보스만 필터링
            const deadBosses = bosses.filter(boss => boss.status === 'dead' && !boss.fixed);
            
            if (deadBosses.length === 0) {
                showNotification('리젠할 보스가 없습니다.');
                return;
            }
            
            if (confirm(`${deadBosses.length}마리의 보스를 모두 리젠하시겠습니까?\n\n⚠️ 서버 점검 후 사용 - 모든 컷 시간이 초기화됩니다!`)) {
                // Firebase 배치 업데이트를 위한 객체 준비 (모든 보스 컷 시간 초기화)
                const updates = {};
                
                deadBosses.forEach(boss => {
                    updates[`${boss.id}/status`] = 'alive';
                    // 전체 리젠 시 모든 보스의 컷 시간 초기화 (서버 점검 후 새로 시작)
                    updates[`${boss.id}/lastKilled`] = null;
                    updates[`${boss.id}/nextRespawn`] = null;
                    updates[`${boss.id}/unregistered`] = false;
                    updates[`${boss.id}/autoProcessed`] = false;
                });
                
                // 배치 업데이트 실행
                bossTimersRef.update(updates)
                    .then(() => {
                        playRespawnSound(); // 전체 리젠 사운드 재생
                        showNotification(`${deadBosses.length}마리의 보스가 모두 리젠되었습니다!`);
                    })
                    .catch((error) => {
                        console.error('전체 리젠 실패:', error);
                        showNotification('전체 리젠에 실패했습니다.');
                    });
            }
        }

        // 빠른 처치 기능
        function processQuickKill() {
            if (!bosses || !Array.isArray(bosses)) {
                console.error('보스 데이터가 아직 로드되지 않았습니다.');
                showNotification('보스 데이터를 불러오는 중입니다. 잠시 후 다시 시도해주세요.');
                return;
            }
            
            console.log('processQuickKill 함수 실행됨');
            const input = document.getElementById('quickKillInput');
            const inputText = input.value.trim();
            
            console.log('입력된 텍스트:', inputText);
            
            if (!inputText) {
                showNotification('보스 이름을 입력해주세요.');
                return;
            }
            
            // "ㅋ" 또는 "컷" 키워드 확인
            const killKeywords = ['ㅋ', '컷'];
            let bossName = '';
            let isKillCommand = false;
            let customTime = null;
            
            // 시간 패턴 확인 (HHMMSS 또는 HHMM 형식)
            const timePattern = /^(\d{6}|\d{4})\s+/;
            const timeMatch = inputText.match(timePattern);
            let remainingText = inputText;
            
            if (timeMatch) {
                const timeStr = timeMatch[1];
                const now = new Date();
                customTime = new Date();
                
                // 시간 부분을 제외한 나머지 텍스트 추출
                remainingText = inputText.substring(timeMatch[0].length);
                
                if (timeStr.length === 6) {
                    // HHMMSS 형식
                    const hours = parseInt(timeStr.substring(0, 2));
                    const minutes = parseInt(timeStr.substring(2, 4));
                    const seconds = parseInt(timeStr.substring(4, 6));
                    
                    if (hours >= 0 && hours <= 48 && minutes >= 0 && minutes <= 59 && seconds >= 0 && seconds <= 59) {
                        customTime.setHours(hours, minutes, seconds, 0);
                    } else {
                        showNotification('올바른 시간 형식이 아닙니다. (HHMMSS)');
                        return;
                    }
                } else if (timeStr.length === 4) {
                    // HHMM 형식
                    const hours = parseInt(timeStr.substring(0, 2));
                    const minutes = parseInt(timeStr.substring(2, 4));
                    
                    if (hours >= 0 && hours <= 48 && minutes >= 0 && minutes <= 59) {
                        customTime.setHours(hours, minutes, 0, 0);
                    } else {
                        showNotification('올바른 시간 형식이 아닙니다. (HHMM)');
                        return;
                    }
                }

                // 입력된 시간이 현재 시간보다 최대 24시간 이상 이전인 경우 에러
                const timeDiff = now - customTime;
                if (timeDiff < 0) {
                    showNotification('미래 시간은 입력할 수 없습니다.');
                    return;
                }
                if (timeDiff > 24 * 60 * 60 * 1000) {
                    showNotification('24시간 이상 이전의 시간은 입력할 수 없습니다.');
                    return;
                }
                
                console.log('입력된 시간:', timeStr);
                console.log('변환된 시간:', customTime.toLocaleString());
                console.log('현재 시간:', now.toLocaleString());
            }
            
            // "ㅋ" 또는 "컷" 키워드로 보스 이름 추출
            for (const keyword of killKeywords) {
                if (remainingText.includes(keyword)) {
                    isKillCommand = true;
                    bossName = remainingText.split(keyword)[0].trim();
                    break;
                }
            }
            
            if (!isKillCommand) {
                showNotification('처치 명령어를 찾을 수 없습니다. "ㅋ" 또는 "컷"을 입력해주세요.');
                return;
            }
            
            if (!bossName) {
                showNotification('보스 이름을 입력해주세요.');
                return;
            }
            
            console.log('현재 보스 목록:', bosses);
            
            // 보스 이름으로 검색 (부분 일치 허용)
            let matchingBosses = bosses.filter(boss => {
                if (!boss || !boss.name) return false;
                
                const searchName = bossName.toLowerCase().trim();
                const targetName = boss.name.toLowerCase().trim();
                console.log(`비교: 입력='${searchName}', 보스='${targetName}'`);
                
                // 정확한 일치
                if (targetName === searchName) return true;
                
                // 입력된 이름이 '하드'로 끝나는 경우 (예: "케르하드")
                if (searchName.endsWith('하드')) {
                    // 대상 보스가 하드보스가 아니면 매칭 안함
                    if (!targetName.endsWith('하드')) return false;
                    
                    // 하드를 제외한 부분이 보스 이름의 시작 부분과 일치하는지 확인
                    const searchBase = searchName.slice(0, -2); // "하드" 제외
                    const targetBase = targetName.slice(0, -2); // "하드" 제외
                    return targetBase.startsWith(searchBase) && searchBase.length >= 2;
                }
                
                // 입력된 이름이 '하드'로 끝나지 않는 경우 (일반 보스 검색)
                if (!searchName.endsWith('하드')) {
                    // 하드보스는 매칭에서 제외
                    if (targetName.endsWith('하드')) return false;
                    
                    // 일반 보스의 경우 시작 부분 매칭 허용 (최소 2글자)
                    return targetName.startsWith(searchName) && searchName.length >= 2;
                }
                
                return false;
            });

            // 매칭된 보스가 여러 개인 경우 처리
            if (matchingBosses.length > 1) {
                const matchedNames = matchingBosses.map(b => b.name).join(', ');
                showNotification(`"${bossName}"와(과) 일치하는 보스가 여러 개 있습니다 (${matchedNames}). 더 정확한 이름을 입력해주세요.`);
                return;
            }
            
            // 매칭된 보스가 없는 경우
            if (matchingBosses.length === 0) {
                showNotification(`"${bossName}" 보스를 찾을 수 없습니다.`);
                return;
            }

            const matchedBoss = matchingBosses[0];
            console.log('매칭된 보스:', matchedBoss);
            
            // 보스가 이미 dead 상태인 경우
            if (matchedBoss.status === 'dead') {
                console.log('사망 상태 보스 처리 시작');
                // 먼저 리젠 처리 (미등록 상태는 보존)
                const revivedBoss = {
                    ...matchedBoss,
                    status: 'alive',
                    lastKilled: null,
                    nextRespawn: null,
                    autoProcessed: false
                };
                
                // Firebase에서 리젠 후 즉시 처치
                bossTimersRef.child(matchedBoss.id.toString()).update(revivedBoss)
                    .then(() => {
                        console.log('리젠 완료, 처치 진행');
                        speak(`${matchedBoss.name} 보스가 리젠되었습니다.`); // TTS 사용
                        // 리젠 후 즉시 처치
                        const killTime = customTime || new Date();
                        const killedBoss = {
                            ...revivedBoss,
                            status: 'dead',
                            lastKilled: killTime.toISOString(),
                            nextRespawn: new Date(killTime.getTime() + matchedBoss.respawnTime * 60000).toISOString(),
                            unregistered: false,
                            autoProcessed: false  // 수동 처치로 처리
                        };
                        
                        return bossTimersRef.child(matchedBoss.id.toString()).update(killedBoss);
                    })
                    .then(() => {
                        const respawnHours = Math.floor(matchedBoss.respawnTime / 60);
                        const respawnMins = matchedBoss.respawnTime % 60;
                        const respawnTimeText = respawnHours > 0 ? `${respawnHours}시간 ${respawnMins}분` : `${respawnMins}분`;
                        const timeText = customTime ? 
                            `${customTime.getHours().toString().padStart(2, '0')}:${customTime.getMinutes().toString().padStart(2, '0')}:${customTime.getSeconds().toString().padStart(2, '0')}` : 
                            '현재 시간';
                        
                        speak(`${matchedBoss.name} 보스를 처치했습니다!`); // TTS 사용
                        showNotification(`${matchedBoss.name} 보스를 처치했습니다!`);
                    })
                    .catch((error) => {
                        console.error('리젠 후 처치 실패:', error);
                        showNotification('처리 중 오류가 발생했습니다.');
                    });
                
                // 입력 필드 초기화
                input.value = '';
                input.focus(); // blur() -> focus()로 변경
                return;
            }
            
            console.log('보스 처치 실행:', matchedBoss.name);
            
            // 보스 처치 실행 (시간 지정 처치)
            const now = customTime || new Date();
            const updatedBoss = {
                ...matchedBoss,
                status: 'dead',
                lastKilled: now.toISOString(),
                nextRespawn: new Date(now.getTime() + matchedBoss.respawnTime * 60000).toISOString(),
                unregistered: false,
                autoProcessed: false  // 수동 처치로 처리
            };
            
            bossTimersRef.child(matchedBoss.id.toString()).update(updatedBoss)
                .then(() => {
                    const timeText = customTime ? 
                        `${customTime.getHours().toString().padStart(2, '0')}:${customTime.getMinutes().toString().padStart(2, '0')}:${customTime.getSeconds().toString().padStart(2, '0')}` : 
                        '현재 시간';
                    speak(`${matchedBoss.name} 보스를 처치했습니다!`); // TTS 사용
                    showNotification(`${matchedBoss.name} 보스를 처치했습니다!`);
                })
                .catch((error) => {
                    console.error('보스 처치 업데이트 실패:', error);
                    showNotification('업데이트에 실패했습니다.');
                });
            
            // 입력 필드 초기화
            input.value = '';
            input.focus(); // blur() -> focus()로 변경
        }

        // 통계 업데이트
        function updateStats() {
            const total = bosses.length;
            const alive = bosses.filter(b => b.status === 'alive').length;
            const dead = bosses.filter(b => b.status === 'dead').length;
            const respawnSoon = bosses.filter(b => {
                if (b.status === 'dead' && b.nextRespawn) {
                    const timeDiff = new Date(b.nextRespawn) - new Date();
                    return timeDiff > 0 && timeDiff <= 600000; // 10분 이내
                }
                return false;
            }).length;
            
            document.getElementById('totalBosses').textContent = total;
            document.getElementById('aliveBosses').textContent = alive;
            document.getElementById('deadBosses').textContent = dead;
            document.getElementById('respawnSoon').textContent = respawnSoon;
        }
        
        // 알림 표시
        function showNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            setTimeout(() => notification.classList.add('show'), 100);
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => document.body.removeChild(notification), 300);
            }, 3000);
        }

        // 사운드 토글 함수
        function toggleSound() {
            soundEnabled = !soundEnabled;
            localStorage.setItem('soundEnabled', soundEnabled.toString());
            updateSoundButton();
            
            if (soundEnabled) {
                showNotification('🔊 사운드가 활성화되었습니다');
                // 테스트 사운드 재생
                playRespawnSound();
            } else {
                showNotification('🔇 사운드가 비활성화되었습니다');
            }
        }

        // 사운드 버튼 업데이트
        function updateSoundButton() {
            const soundButton = document.getElementById('soundToggle');
            if (soundButton) {
                soundButton.textContent = soundEnabled ? '🔊' : '🔇';
                soundButton.title = soundEnabled ? '사운드 끄기' : '사운드 켜기';
            }
        }

        function setBossFilter(filter) {
            bossFilter = filter;
            renderBossesUI();
            // 선택 효과
            document.querySelectorAll('.stat-card').forEach(card => card.classList.remove('selected'));
            if (filter === 'all') document.getElementById('statTotal').classList.add('selected');
            if (filter === 'alive') document.getElementById('statAlive').classList.add('selected');
            if (filter === 'dead') document.getElementById('statDead').classList.add('selected');
            if (filter === 'soon') document.getElementById('statSoon').classList.add('selected');
        }

        // 고정보스 등록 폼 제출 처리
        document.getElementById('fixedBossForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            if (!isLoggedIn) {
                showNotification('관리자만 보스를 등록할 수 있습니다.');
                return;
            }
            
            const name = document.getElementById('fixedBossName').value.trim();
            const location = document.getElementById('fixedLocation').value.trim() || '미설정';
            const hour = parseInt(document.getElementById('fixedHour').value);
            const minute = parseInt(document.getElementById('fixedMinute').value);
            
            // 선택된 요일 배열 생성
            const selectedDays = [];
            for (let i = 0; i < 7; i++) {
                if (document.getElementById(`fixedDay${i}`).checked) {
                    selectedDays.push(i);
                }
            }
            
            if (!name) {
                showNotification('보스 이름을 입력해주세요.');
                return;
            }
            
            if (selectedDays.length === 0) {
                showNotification('최소 하나의 요일을 선택해주세요.');
                return;
            }
            
            if (isNaN(hour) || isNaN(minute) || 
                hour < 0 || hour > 48 || 
                minute < 0 || minute > 59) {
                showNotification('올바른 시간을 입력해주세요.');
                return;
            }
            
            // 새 보스 데이터 생성
            const newBoss = {
                id: Date.now(),
                name: name,
                location: location,
                fixed: true,
                fixedDays: selectedDays,
                fixedHour: hour,
                fixedMinute: minute,
                status: 'dead',  // 초기 상태를 dead로 변경
                lastKilled: null,
                nextRespawn: null,
                respawnTime: 0,
                autoProcessed: false,  // autoProcessed 추가
                unregistered: false    // unregistered 추가
            };
            
            // Firebase에 저장
            bossTimersRef.child(newBoss.id.toString()).set(newBoss)
                .then(() => {
                    // 폼 초기화
                    document.getElementById('fixedBossName').value = '';
                    document.getElementById('fixedLocation').value = '';
                    document.getElementById('fixedHour').value = '0';
                    document.getElementById('fixedMinute').value = '0';
                    // 요일 체크박스 초기화
                    for (let i = 0; i < 7; i++) {
                        document.getElementById(`fixedDay${i}`).checked = false;
                    }
                    
                    showNotification(`${name} 보스가 등록되었습니다!`);
                })
                .catch((error) => {
                    console.error('보스 등록 실패:', error);
                    showNotification('보스 등록에 실패했습니다.');
                });
        });

        // 시간 입력 유효성 검사 함수 추가
        function validateTimeInput(input, min, max) {
            let value = parseInt(input.value);
            if (isNaN(value) || value < min || value > max) {
                value = Math.min(Math.max(min, value || 0), max);
                input.value = value;
            }
        }

        // 보스 처치 처리 함수
        function processBossKill(boss, killTime) {
            const updates = {};
            updates[`${boss.id}/killTime`] = killTime;
            updates[`${boss.id}/status`] = 'dead';
            // 사운드 안내를 최우선으로 실행
            speak(`${boss.name} 보스가 처치되었습니다.`);
            bossTimersRef.update(updates)
                .then(() => {
                    console.log('처치 시간 업데이트 완료');
                })
                .catch(error => {
                    console.error('처치 시간 업데이트 실패:', error);
                    showNotification('❌ 처치 시간 업데이트 실패');
                });
        }

        // 보스 리젠 처리 함수
        function processBossRespawn(boss) {
            const updates = {};
            updates[`${boss.id}/killTime`] = null;
            updates[`${boss.id}/status`] = 'alive';
            // 사운드 안내를 최우선으로 실행
            speak(`${boss.name} 보스가 리젠되었습니다.`);
            bossTimersRef.update(updates)
                .then(() => {
                    console.log('리젠 처리 완료');
                })
                .catch(error => {
                    console.error('리젠 처리 실패:', error);
                    showNotification('❌ 리젠 처리 실패');
                });
        }

        // 자동 업데이트 처리
        function processAutoUpdates(updates, hasRespawns) {
            bossTimersRef.update(updates)
                .then(() => {
                    console.log('자동 처리 업데이트 완료');
                })
                .catch(error => {
                    console.error('자동 업데이트 실패:', error);
                    showNotification('❌ 자동 업데이트 실패');
                });
        }

        // 페이지 로드 시 준비 완료 알림
        window.addEventListener('load', () => {
            showNotification('🔊 보스 타이머가 준비되었습니다. 음성 안내가 재생됩니다.');
        });

        // 보스 처치 버튼 클릭 핸들러
        function handleKillClick(boss) {
            console.log('처치 버튼 클릭:', boss.name);
            handleBossEvent(boss, true);
        }

        // 보스 리젠 버튼 클릭 핸들러
        function handleRespawnClick(boss) {
            console.log('리젠 버튼 클릭:', boss.name);
            handleBossEvent(boss, false);
        }

        // 보스 요소 생성 함수
        function createBossElement(boss) {
            const bossDiv = document.createElement('div');
            bossDiv.className = 'boss-item';
            bossDiv.id = `boss-${boss.id}`;

            const bossName = document.createElement('div');
            bossName.className = 'boss-name';
            bossName.textContent = boss.name;

            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'button-container';

            const killButton = document.createElement('button');
            killButton.className = 'action-button kill-button';
            killButton.textContent = '처치';
            killButton.onclick = () => handleKillClick(boss);

            const respawnButton = document.createElement('button');
            respawnButton.className = 'action-button respawn-button';
            respawnButton.textContent = '리젠';
            respawnButton.onclick = () => handleRespawnClick(boss);

            const timerDisplay = document.createElement('div');
            timerDisplay.className = 'timer-display';
            timerDisplay.id = `timer-${boss.id}`;

            buttonContainer.appendChild(killButton);
            buttonContainer.appendChild(respawnButton);
            buttonContainer.appendChild(timerDisplay);

            bossDiv.appendChild(bossName);
            bossDiv.appendChild(buttonContainer);

            return bossDiv;
        }



        // 보스 데이터 업데이트 처리
        function updateBossData() {
            const now = new Date().getTime();
            const updates = {};
            let hasRespawns = false;

            bosses.forEach(boss => {
                const timerElement = document.getElementById(`timer-${boss.id}`);
                const bossElement = document.getElementById(`boss-${boss.id}`);
                
                if (!timerElement || !bossElement) return;

                const killTime = boss.killTime;
                if (!killTime) {
                    timerElement.textContent = '대기 중';
                    bossElement.classList.remove('dead');
                    return;
                }

                const respawnTime = new Date(killTime + boss.respawnHours * 60 * 60 * 1000);
                const timeDiff = respawnTime - now;

                if (timeDiff <= 0 && boss.status === 'dead') {
                    updates[`${boss.id}/status`] = 'alive';
                    updates[`${boss.id}/killTime`] = null;
                    hasRespawns = true;
                    boss.status = 'alive';
                    boss.killTime = null;
                }

                if (boss.status === 'dead') {
                    const hours = Math.floor(timeDiff / (60 * 60 * 1000));
                    const minutes = Math.floor((timeDiff % (60 * 60 * 1000)) / (60 * 1000));
                    timerElement.textContent = `${hours}시간 ${minutes}분`;
                    bossElement.classList.add('dead');
                } else {
                    timerElement.textContent = '대기 중';
                    bossElement.classList.remove('dead');
                }
            });

            if (Object.keys(updates).length > 0) {
                bossTimersRef.update(updates)
                    .then(() => {
                        console.log('자동 처리 업데이트 완료');
                        if (hasRespawns) {
                            // 리젠된 보스들에 대해 TTS 실행
                            Object.keys(updates).forEach(key => {
                                if (key.endsWith('/status') && updates[key] === 'alive') {
                                    const bossId = key.split('/')[0];
                                    const boss = bosses.find(b => b.id.toString() === bossId);
                                    if (boss) {
                                        speak(`${boss.name} 보스가 리젠되었습니다.`);
                                    }
                                }
                            });
                        }
                    })
                    .catch(error => {
                        console.error('자동 업데이트 실패:', error);
                        showNotification('❌ 자동 업데이트 실패');
                    });
            }
        }

        // 보스 처치/리젠 이벤트 핸들러
        function handleBossEvent(boss, isKill = true) {
            const updates = {};
            if (isKill) {
                updates[`${boss.id}/killTime`] = new Date().getTime();
                updates[`${boss.id}/status`] = 'dead';
            } else {
                updates[`${boss.id}/killTime`] = null;
                updates[`${boss.id}/status`] = 'alive';
            }
            // TTS 호출 제거 (Firebase 리스너에서만 실행)
            bossTimersRef.update(updates)
                .then(() => {
                    console.log(isKill ? '처치 시간 업데이트 완료' : '리젠 처리 완료');
                })
                .catch(error => {
                    console.error(isKill ? '처치 시간 업데이트 실패' : '리젠 처리 실패', error);
                    showNotification('❌ ' + (isKill ? '처치 시간 업데이트 실패' : '리젠 처리 실패'));
                });
        }

        // 설명서 모달 열기/닫기 및 파일 불러오기

        document.getElementById('helpIcon').onclick = function() {
            const modal = document.getElementById('helpModal');
            const helpText = document.getElementById('helpText');
            modal.style.display = 'block';
            helpText.textContent = `게임 보스 리젠 타이머 상세 사용 설명서\n\n────────────────────────────\n\n■ 1. 프로그램 개요\n- 이 프로그램은 게임 내 보스 몬스터의 리젠(부활) 시간과 처치(컷) 기록을 실시간으로 관리합니다.\n- 일반 보스와 고정(요일/시간 지정) 보스를 모두 지원합니다.\n- 관리자 권한, 자동처리, 빠른처치, 통계, 알림, 음성 안내(TTS) 등 다양한 기능이 포함되어 있습니다.\n\n────────────────────────────\n\n■ 2. 관리자 로그인/권한\n- 관리자만 보스 추가, 삭제, 전체 리젠, 고정보스 등록이 가능합니다.\n- [관리자] 버튼 클릭 → 이메일/비밀번호 입력 후 로그인\n- 로그인 성공 시 \"관리자\"로 표시, 실패 시 \"이메일 또는 비밀번호가 잘못되었습니다.\" 알림\n- 로그아웃 시 \"게스트 모드\"로 전환, 관리자 기능 숨김\n\n────────────────────────────\n\n■ 3. 보스 등록/수정/삭제\n\n[일반 보스 등록]\n1) \"새 보스 추가\" 폼에 이름, 리젠 시간(시간/분), 위치 입력\n2) [보스 추가] 클릭\n- 예시: 이름: 타우록스 / 리젠: 2시간 30분 / 위치: 화산 던전 3층\n- 리젠 시간은 1~48시간, 분은 0~59분만 입력 가능 (초과 시 자동 보정)\n- 시간/분 미입력 또는 0 입력 시 \"리젠 시간을 입력해주세요.\" 경고\n- 48시간 초과 입력 시 \"리젠 시간은 최대 48시간까지 입력 가능합니다.\" 경고\n\n[고정 보스 등록]\n1) \"고정보스 등록\" 폼에서 이름, 출현 요일(체크), 출현 시간(시/분), 위치 입력\n2) [보스 등록] 클릭\n- 예시: 이름: 드래곤 킹 / 요일: 월, 목, 토 / 시간: 21:00 / 위치: 용의 둥지\n- 요일 미선택 시 \"최소 하나의 요일을 선택해주세요.\" 경고\n- 시간/분 미입력, 범위 초과 시 \"올바른 시간을 입력해주세요.\" 경고\n\n[수정/삭제]\n- 각 보스 우측 [수정] 클릭 → 정보 수정 후 저장\n- [삭제] 클릭 시 \"정말로 이 보스를 삭제하시겠습니까?\" 팝업 후 삭제\n- 삭제/수정은 관리자만 가능\n\n────────────────────────────\n\n■ 4. 보스 처치/리젠/전체 리젠\n\n[개별 처치]\n- [처치] 클릭 시 즉시 처치 처리(팝업 없음), \"보스를 처치했습니다!\" 알림 및 TTS\n\n[개별 리젠]\n- [리젠] 클릭 시 \"정말로 이 보스를 리젠 처리하시겠습니까?\" 팝업 → [확인] 시 리젠 처리, \"보스가 리젠되었습니다!\" 알림 및 TTS\n\n[전체 리젠]\n- \"설정\" 영역의 [🔄 전체 리젠] 클릭 → \"모든 컷 시간이 초기화됩니다!\" 안내 후 [확인] 시 전체 리젠\n- 관리자만 가능, 고정보스는 제외됨\n\n────────────────────────────\n\n■ 5. 빠른 처치 입력 (⚡ 빠른 처치)\n- 입력창에 \"보스이름 ㅋ\" 또는 \"보스이름 컷\" 입력 → 해당 보스 즉시 처치\n- 시간 지정: \"HHMM 보스이름 ㅋ\" 또는 \"HHMMSS 보스이름 컷\" (예: 0930 타우록스 ㅋ, 211530 타우록스 컷)\n- 하드보스: 반드시 '하드'로 끝나야 함 (예: 타우록스하드 ㅋ)\n- 보스 이름은 2글자 이상 입력, 부분 일치 허용(동명이인 다수시 \"더 정확한 이름을 입력해주세요.\" 안내)\n- 예시:\n  - 타우록스 ㅋ\n  - 2359 타우록스 컷\n  - 2100 드래곤 ㅋ\n  - 093000 타우록스하드 컷\n- 입력 오류/예외:\n  - \"처치 명령어를 찾을 수 없습니다. 'ㅋ' 또는 '컷'을 입력해주세요.\"\n  - \"보스 이름을 입력해주세요.\"\n  - \"보스를 찾을 수 없습니다.\" 또는 \"여러 개 있습니다\" 등 안내\n\n────────────────────────────\n\n■ 6. 자동처리/미등록\n- 리젠 후 5분간 처치 입력이 없으면 자동으로 '미등록' 상태로 전환(카드에 '미등록' 표시)\n- 미등록 상태는 다음 리젠 때까지 유지, 이후 자동 해제\n- 고정보스는 리젠 시간에 맞춰 자동으로 alive로 변경됨(수동 처치 시 자동처리 제외)\n- 자동처리/자동 미등록/자동 리젠 모두 TTS 및 알림 동작\n\n────────────────────────────\n\n■ 7. 통계/필터/정렬\n- 상단 통계 카드(총 보스, 생존, 사망, 곧 리젠) 클릭 시 해당 상태만 필터링\n- 곧 리젠: 10분 이내 리젠 예정인 보스\n- 보스 목록은 상태, 리젠 남은 시간, 이름, 고정/일반 순서로 자동 정렬\n\n────────────────────────────\n\n■ 8. 알림/음성 안내(TTS)/사운드\n- 모든 주요 작업(추가, 삭제, 리젠, 처치, 자동처리 등) 시 화면 우측에 알림 표시(3초간)\n- TTS(음성 안내)는 브라우저 지원 시 자동 재생, 스피커 버튼(🔊/🔇)으로 켜고 끌 수 있음\n- 브라우저 미지원 시 \"음성 안내를 지원하지 않는 브라우저입니다.\" 안내\n\n────────────────────────────\n\n■ 9. 입력 유효성/예외 상황\n- 시간/분/요일 등 입력값이 잘못되면 즉시 경고 및 입력값 자동 보정\n- 관리자 권한 없는 경우 \"관리자만 ○○할 수 있습니다.\" 안내\n- 네트워크/DB 오류 시 \"업데이트에 실패했습니다.\" 등 에러 알림\n- 모달(로그인/수정) ESC키, 바깥 클릭, Enter키로 닫기/저장 가능\n\n────────────────────────────\n\n■ 10. 기타 팁/FAQ\n- 보스 이름은 2글자 이상 입력해야 검색/처치 가능\n- 하드보스는 반드시 '하드'로 끝나야 하며, 일반/하드 구분 엄격\n- 고정보스는 요일+시간 지정, 일반 보스는 리젠 시간(분 단위) 지정\n- 위치 미입력 시 \"미설정\"으로 자동 입력\n- 빠른처치 입력창은 보스가 1개 이상 등록되어야 활성화됨\n- 관리자 비밀번호 분실 시 개발자에게 문의\n\n────────────────────────────\n\n■ 실제 사용 예시\n1. 타우록스가 23:59에 컷!\n  - 빠른처치 입력창에 2359 타우록스 ㅋ 입력 후 엔터 또는 [입력] 클릭\n2. 드래곤 킹이 리젠됨\n  - 드래곤 킹 우측 [리젠] 클릭 → 팝업에서 [확인]\n3. 전체 보스 리젠\n  - \"설정\" 영역의 [🔄 전체 리젠] 클릭 → 팝업에서 [확인]\n4. 5분 미등록 자동 처리\n  - 리젠 후 5분간 처치 입력이 없으면 자동으로 '미등록' 상태로 표시됨\n5. 고정보스 등록 예시\n  - 이름: 케르베로스 하드 / 요일: 수, 토 / 시간: 22:30 / 위치: 지옥문\n\n────────────────────────────\n\n궁금한 점이나 추가 설명이 필요한 부분이 있으면 언제든 문의해 주세요!`;
};
        document.getElementById('closeHelpModal').onclick = function() {
            document.getElementById('helpModal').style.display = 'none';
        };
        window.addEventListener('click', function(e) {
            const modal = document.getElementById('helpModal');
            if (e.target === modal) modal.style.display = 'none';
        });
    </script>
</body>
</html> 
